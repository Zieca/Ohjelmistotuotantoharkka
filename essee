Kurssin harjoitustehtävä päätettiin toteuttaa analyysinä töistä ja projekteista joita koulun yhteydessä
on ennestään toteutettu. Tarkoituksena on koota yhteen kaikki käytössä olleet työvälineet ja käytetyt menetelmät
tarkastellen näiden moninaisuutta ja toimivuutta toisiinsa nähden. Lisäksi pohditaan jo käytettyjen menetelmien ja 
välineiden yhteneväisyyttä ohjelmistotoutannon kurssin aikana käytyjen asioiden kanssa, sekä kuinka kurssin aikana 
opittujen menetelmien ja työvälineiden hyödyntäminen olisi vaikuttanut tehtyjen projektien / töiden toteuttamiseen.
Analyysiä varten on yhteen koottu kaikkien ryhmän jäsenten kokemukset. 

Projektit luodaan yleensä annettua työtehtävää varten. Näin ollen projektit ovat loppujen lopuksi samantyylisiä. 
Projekteihin sisältyy aina tavoite, johon asiakas/projektin määrääjä pyrkii lopputuloksessa. Projekteissa on aina 
alku ja loppu, vaikka aloitus olosuhteet vaihtelevat, niin näitä kahta pääasiaa voidaan pitää kaikissa projekteissa 
yhtenevänä tekijänä. Kaikki tavat, kuinka projektit saadaan alusta loppuun asti tehtyä vaihtelevat projektien sisällä, 
oli se sitten pieni ryhmätyöprojekti tai laaja asiakasprojekti.

Projektit sisältävät aina päämäärän, johon projektiin osalliset vaikuttavat parhaansa mukaan.
Näin ollen lopputulokseksi saadaan yleensä aina edes lähelle haluttua lopputulosta ollut loppu-
tulos. Tämä edellyttää projektiryhmältä kykyä suunnitella projektin etenemistä ja kommunikoida toistensa kanssa. 

Projekteja on kolmenlaisia: Onnistuneita, epäonnistuneita ja kesken olevia. Näistä kolmesta  
voidaan erotella erilaisia syitä lopputuloksen eroavaisuuden suhteen. Onnistuneet projektit vaa-
tivat tekijöiltään omistautumista ja lujaa uskoa projektin lopputuloksen saavuttamiseksi, näitä ovat 
muun muassa erilaiset palaverit sekä muunlaiset keskustelu hetket siitä, että missä vaiheessa 
projektin suhteen olemme etenemässä, mitä tulee tehdä / mitä on jäänyt tekemättä ja mitenkä
aikataulullisesti projektissa tulisi edetä. 

Projektien etenemiseen vaikuttaa myös tietynnäköinen etenemismalli. Tähän liittyen voidaan 
käyttää projektin kesken erilaisia käyttöliittymiä, jotka mahdollistavat projektin osallisien helpon
kommunikoinnin keskenään. Oli se sitten GitHub:n tai Google doc:n, mutta pääasia on, että 
projektin jäsenet voivat osallistua projektin tekemiseen, niin monipuolisesti kuin se vain suinkin
on mahdollista. Kun projektin osallistujien monipuolisuus, sekä tavoitteet ovat samansuuntaisia
tulee projektista yleensä onnistunut asiakkaalle sekä projektiryhmälle.

Projektien onnistumista voidaan kuvata myös siltä kannalta, kuinka hyvin projektin “suunnittelu” 
on onnistunut. Yleensä myös tähän osaan kohdistuu projekteissa eniten parannettavaa. Onnistu-
neissa projekteissa haluttuun lopputulokseen pääsemiseksi on hyvä olla käytössä suunnitelma, 
jota noudatetaan koko projektin ajan. Yleensä suunnitelmissa (“aivoriihissä”) osataan ottaa mukaan asioita, 
joita ei huomaisi ottavan mukaan projektiin muissa tapauksissa. Tämän vuoksi projektin eteneminen myöhemmässä 
tapauksessa saattaa pysähtyä kriittisellä hetkellä, ja näin
ollen vaikuttaa myös projekteihin määrättyihin deadlineihin sekä mahdolliseen budjettiin. Yhteen-
vetona voitaisiinkin sanoa, että mahdollinen suunnittelu projektin osalta on tärkeimpiä osa-alueita 
ja näin ollen vaikuttaa suoraan projektin onnistumisen määritelmään.

Opintojen puitteissa tehdyt pienet tehtävät ja harjoitukset, etenkin ohjelmontipuolella on yleensä tehty ns. 
yritys-erehdys menetelmällä (tai kuten yksi kurssin vierailijoista sanoisi, perse eellä puuhun -menetelmällä), 
koska varsinaista suunnittelua ei ole koettu tarpeelliseksi. Jälkikäteen näitä töitä tarkastelemalla on kuitenkin 
voinut todeta, että suunnittelu ja työn pienempiin osiin purkaminen olisi voinut olla kannattavaa. Toisaalta ohjelmien 
jäsentely ja osiin pilkkominen on taito, joka on kehittynyt opintojen edetessä, jolloin on luonnollista, että opintojen
alkuvaiheen ohjelmointityöt ovat karkeaa, sekavaa ja äärimmäisen huonolaatuista koodia.
Tässä samassa yhteydessä on myös käynyt ilmi kuinka tärkeää työn/tehtävän oikeanlainen määrittely ennen suunnittelua 
ja toteutusta on. Esimerkkinä tästä toimii toisena opintovuonna ohjelmointikurssin yhteydessä tehty harjoitustyö. 
Harjoituksena ideana oli, että se koostuu useammasta osasta ja osien ohjeita ei saatu kerralla. Tämän vuoksi 
kokonaisuutta ei ollut mahdollista suunnitella siten, että jatko-ohjeiden vaatimusten täyttäminen olisi ollut 
vaivatonta tai edes mielekästä. Tästä syystä aikaa ja vaivaa työhön kului paljon enemmän kuin todellisessa 
työprojektissa olisi ollut suotavaa.
Oppina siis, speksit kasaan heti alussa. Pienet muutokset ja muokkaukset voivat olla ok, mutta mikäli halutaan 
rakenteellisia muutoksia tai lisäelementtejä projektiin jotka vaatisivat rakenteellisia muutoksia liikutaan heikoilla 
jäillä onnistumisen ja tehokkaan työn suhteen.

Teknologioiden osalta tarkastelussa on ne työalustat (ohjelmat) ja ohjelmointikielet, joita opintojen aikana on 
ollut käytössä. Selvitetään minkä tyyppisissä töissä mitäkin on käytetty ja olisiko joku muu käytäntö tai työväline 
ollut käytettyä parempi.

Ensimmäisenä tarkastellaan miniprojekteja eli koulun ohjelmointikurssien harjoitustehtäviä opintojen alkuvaiheessa. 
Ensimmäinen tuttavuus valtaosalle ryhmäläisistä työalustana oli Dev-C++ c-ohjelmoinnin alkeiskurssilla. Kyseessä on
kohtuullisen keveähkö windows-käyttöjärjästelmässä käytettävä ohjelmointiympäristö C- ja C++ kielille. Tämän ohjelman 
heikkoudeksi aloittelevien koodaajien käsissä osoittautui virheiden tunnistus ja jäljityksen vaikeus. Ohjelman 
varsinainen käyttö oli kuitenkin suhteellisen vaivatonta. Koodielementtien vaiteleva väritys (ominaisuus monissa 
ohjelmointialustoissa) auttaa tunnistamaan koodin osia ja rakennetta. Yhdellä ryhmän jäsenistä käytössä oli Emacs 
työkaluna, mutta tämä ohjelma ei ole kovinkaan aloittelijaystävällinen, jos käytön joutuu opettelemaan ilman osaavan 
henkilön apupanosta. Emacsin hyviä puolia kuitenkin käyttäjäystävällisyys (kun perusasiat on vain hallussa käytöstä),
koodi väritys (kuten dev-c++:kin), automaattinen sisennys joka poistaa ylimääräiseen tarpeen kiinnittää huomiota ja
vaivaa koodin muotoseikkoihin jolloin valtaosan keskittymisestä voi oikeasti kohdentaa koodin tuottamiseen.
(Koodin väritys ja automaattinen sisennys on kaikissa niissä editoreissa, joita on tarkoitettu käytettävän koodaamiseen.)

Kun ohjelmoinnissa siirryttiin c:stä javaan vaihdettiin myös käytettävä alusta. Uutena työalustana tässä vaiheessa 
esiteltiin Eclipse. Ryhmässä yleisesti vallitseva mielipide on, ettei Eclipse ole käytössä kovinkaan mielekäs työväline.
Vaikka Eclipsellä pienien ohjelmien kirjoittaminen ja niiden toiminnan testaaminen onkin suhteellisen yksinkertaista 
ohjelman käyttö koettiin raskaaksi ja hankalaksi. Ohjelmointikurssien yhteydessä käytössä oli myös Metropolian 
verkko-opetusympäristö Viope, jossa myös tehtiin pieniä ohjelmointitehtäviä. Varsinainen ohjelmointi tässä ympäristössä
oli hyvin samanlaista kuin ohjelmointi notepad++:lla.

Puhtaiden ohjelmointitöiden lisäksi opintoaikana on tehty erilaisia pieniä projekteja joissa ohjelmia on kirjoitettu 
erilaisille laitteille. Pienet työt ovat enimmäkseen olleen erilaisia ledin vilkutusohjelmia ja lcd-näytölle tulostuksia. 
Työalustoina on ollut mm. PSoC Designer, AVR-studio ja Quartus ja c:n lisäksi kielinä mm. assembly ja vhdl.

Suurimpana projektina opiskeluaikana on toteutettu robotin rakentaminen. Ohjelmistoprojektien näkökulmasta kyse ei 
ollut kovinkaan ideaalisesta tapauksesta, koska tuotettava koodin määrä oli suhteellisen pieni osa projektia. 
Työalustoina ohjelman tuottamisessa oli sellaiset työvälineet, joiden käyttöön oli tutustuttu opintojen aikaisemmissa
vaiheissa.

Käytännön tekeminen on yleensä ollut “kertaistumalta”, jolloin työ tehdään kerralla tyhjästä pisteeseen, jossa sen voi 
sanoa olevan valmis. Tämä on todennäköistä silloin, kun kyseessä on pienet irralliset tehtävät ja osasuoritukset. Ainoa 
pitkäjänteisempi suoritus on ollu robotti, jonka tapauksessa tekeminen jakautui neljä kuukautta kestävälle ajanjaksolle. 
Tämä pakotti pilkkomaan työt mahdollisimman pieniin osiin, jotta toteuttaminen oli mahdollista.

Opintojen suurimmassa ja eniten työelämän projekteja muistuttavassa työssä robotti -projektissa käytetty 
projektimenetelmä oli pääasiassa vesiputousmalli. Projekti alkoi sillä, että saimme robotin osat ja aloimme suunnitella 
ja kasaamaan robottia kyseisen projektimenetelmän mukaisesti. Ensin määrittelimme, mitä robotin täytyy pystyä tekemään 
ja sen jälkeen aloimme suunnitella ja toteuttaa sitä vaihe vaiheelta. Projektin ensimmäiset viikot olivat pääasiassa
suunnittelua dokumentointia ennen kuin pääsimme kunnolla tekemään robottia.

Kyseiseen projektiin vesiputousmalli oli toimiva ratkaisu, sillä robotin suunnittelu ja toteuttaminen ei kuitenkaan 
ollut niin iso projekti etteikö sitä olisi valmiiksi pystynyt suunnittelemaan kokonaan alusta loppuun valmiiksi. 
Tosin harvoin mikään projekti on aivan täysin yhden projektimenetelmän mukaan tehty ja myös robotti projektissa oli 
muidenkin menetelmien piirteitä.

Projektin edetessä alkoi kuitenkin tulla joitakin ongelmia vesiputousmallin takia, koska etenkin projektin loppupuolella
robottiin piti tehdä paljon muutoksia, mitä ei etukäteen oltu suunniteltu. Tämä tosin johtui siitä, että robotti 
projekti oli monelle ensimmäinen iso projekti, mitä koulussa tai ylipäätään missään on aiemmin tehty. Tämän vuoksi 
harvalla oli kokemusta projektin tekemisestä tai ylipäätänsä erilaisista projektimenetelmistä, joten käytännössä 
robottia ryhdyttiin vain tekemään, jotta se saataisi valmiiksi.

Jälkeenpäin ajateltuna vesiputousmalli ei kuitenkaan ollut välttämättä paras mahdollinen menetelmän robotti projektin 
kannalta. Kokemuksen puutteen vuoksi ja tietämättömyys erilaisista menetelmistä johti siihen, että robotin suunnitteluun
ja määrittelemiseen jouduttiin palaamaan usein. Robottia jouduttiin muuttamaan useaan kertaan, ennekuin päästiin 
valmiiseen lopputulokseen. Scrum olisi ollut robotti projektin kannalta ehkä parempi vaihtoehto, sillä silloin olisi
ollut helpompi palata takaisin projektisuunnitelmaan ja tehdä tarvittavat muutokset ja testata robottia uudelleen.
Kuten aiemmin mainittu, ei robotti projektia tehtäessä projektin jäsenillä ollut paljon aiempaa kokemusta isommista
projekteista. Ennen sitä olimme pääasiassa tehneet vain pieniä projekteja kuten esimerkiksi erilaisia harjoitustehtäviä
eri kursseihin liittyen. C:n ja Java:n peruskursseilla teimme kurssin harjoitustehtäviä ja sulautettujen ohjelmien 
harjoituskurssilla teimme vain pieniä sovellutuksia, joten mahdollista suunnittelua ei tarvittu, vaan aloimme suoraan 
koodaamaan. Tämä toimi hyvin pienissä harjoitustehtävissä, sillä tehtävät olivat usein niin yksinkertaisia, että 
erillinen suunnittelu ja määrittely olisi saattanut vain haitata tehtävien tekemistä. Tosin välillä saatettiin 
jäsennellä tehtäviä ranskalaisilla viivoilla, millä oli hyvä aloittaa, mutta yhtään enempää suunnittelua ei edes 
kannattanut tehdä.

Ryhmän jäsenillä on erilaisia kokemuksia isomman projektin (robotti) dokumentaation hallinnasta. Osassa tapauksia 
dokumentaatio oli säilötty samaan paikkaan kuin kaikki muukin projektissa tuotettu tulos (koodi), tässä tapauksessa
Tuubiin perustettu työtila. Tässä tapauksessa kaikilla ryhmän jäsenillä oli oikeus tallentaa/korvata/poistaa 
dokumetntaatiota työtilassa. 
Toinen ratkaisu jota käytettiin oli palvelimelle perustettu tila, johon dokumentaatio talletettiin luettavaksi ja 
ladattavaksi. Dokumentaation päivitys palvelimella ei ollut auki kaikille projektiryhmän jäsenille vaan arkiston 
hallinta ja organisointi oli yhden henkilön vastuulla jolle päivitetyt dokumentaatiot ohjattiin arkistoitaviksi.
Molempien käytettyjen tapojen heikkoutena oli dokumenttien eri versioiden määrän suuruus, kun kyseessä oli usein 
päivitetty/muokattu dokumentaatio.

Robottiprojektissa perustettiin repository Bitbuckettiin tai vaihtoehtoisesti tehtiin uusi työtila 
Tuubiin. Jolloin pystyttiin päivittämään aina uusi versio muiden ryhmäläisten näkyville. 
Projektissa suurin osa päivitti alussa aina kaikki muutokset koodissa ja dokumentoinnissa 
repositoryyn, mutta ajan myötä päivitykset vähentyivät ja uusin versio jäi koodia korjanneelle 
henkilölle. Tämän takia olisi voinut tulla ongelmia, jos kyseinen ryhmäläinen menettäisi tiedostot 
jostakin syystä tai jos hän ei pääsisi paikalle yhdessä työskennellessä. Lopulta kuitenkin 
tiedostot jaettiin sähköpostitse tai muilla tavoin.

Projektin alussa tehtävät ja kirjoitettavat koodit jaettiin eri ihmisille, joten periaatteessa 
branchaus toimi. Projektissa mukana olleet yhdistelivät koodia tarpeen tullen, mutta projektin 
edetessä huomattiin, olevan kätevämpää jos kaksi ihmistä kirjoittaa koodia yhdessä. Tällöin 
koodia ei tehty turhaan päällekkäin ja yritetty väkisin yhdistää toimivaksi kokonaisuudeksi. 
Koodiin ei tehty missään vaiheessa testikoodia, mutta koska kyseessä oli robotti, pystyttiin sen 
toimivuus testaamaan fyysisesti. Tosin se oli hieman aikaa vievää. Koodi oli myös selkeästi 
kommentoitua ja parametrit olivat järkeviä. 

Ohjelmistotuotannon oppimisprojektin ideana oli tehdä parempaa projektinhallintaa kuin 
aikaisemmissa projekteissa. Meidän projektiryhmällä ei ollut meneillään yhtäkään kurssia, jossa 
voisi hallintaa harjoitella, joten kurssin harjoitustehtävä päätettiin toteuttaa analyysinä koulssa tehdyistä 
töistä ja projekteista.

Jaoimme projektiohjeessa olevat viisi osiota ryhmämme neljän jäsenen kesken ja kirjoitimme 
osioita joko itseksemme omaan Word tiedostoon tai Google Driveen, jossa kaikki pääsivät 
tekstiin käsiksi. Päätimme kokeilla yhdessä myös githubin toimivuutta, joten loimme tilit ja testailimme
erilaisia branchien ja tiedostojen luomisia ja muokkauksia.

Pohdimme mitä olisi kannattunut tehdä paremmin aiemmissa projekteissa ja töissä, ja päädyimme siihen, että 
projektimallimme ovat aina olleet suht huonoja ja työvälineetkin yleensä heikomman puoleisia. Dokumentaatiokaan
ei ole ollut parhaimmasta päästä (paitsi Suvin panostus roboprojektissa). Joten oikeastaan kaikessa olisi 
parantamisen varaa. 

